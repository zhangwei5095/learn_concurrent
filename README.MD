## 锁

- 自旋锁和使线程休眠的非自旋锁各有什么适用场景？

自旋锁(spin lock)与互斥量(mutex)的比较自旋锁是一种非阻塞锁，也就是说，如果某线程需要获取自旋锁，但该锁已经被其他线程占用时，该
线程不会被挂起，而是在不断的消耗CPU的时间，不停的试图获取自旋锁。互斥量是阻塞锁，当某线程无法获取互斥量时，该线程会被直接挂起，该
线程不再消耗CPU时间，当其他线程释放互斥量后，操作系统会激活那个被挂起的线程，让其投入运行。

两种锁适用于不同场景：
如果是多核处理器，如果预计线程等待锁的时间很短，短到比线程两次上下文切换时间要少的情况下，使用自旋锁是划算的。
如果是多核处理器，如果预计线程等待锁的时间较长，至少比两次线程上下文切换的时间要长，建议使用互斥量。
如果是单核处理器，一般建议不要使用自旋锁。因为，在同一时间只有一个线
程是处在运行状态，那如果运行线程发现无法获取锁，只能等待解锁，但因为自身不挂起，所以那个获取到锁的线程没有办法进入运行状态，只能等
到运行线程把操作系统分给它的时间片用完，才能有机会被调度。这种情况下使用自旋锁的代价很高。如果加锁的代码经常被调用，但竞争情况很少
发生时，应该优先考虑使用自旋锁，自旋锁的开销比较小，互斥量的开销较大。

在竞争激烈的情况下 阻塞锁的性能要明显高于 自旋锁。
理想的情况则是; 在线程竞争不激烈的情况下使用自旋锁，竞争激烈的情况下使用阻塞锁。


可重入锁，也叫做递归锁，指的是同一线程 外层函数获得锁之后 ，内层递归函数仍然有获取该锁的代码，但不受影响。
在JAVA环境下 ReentrantLock 和synchronized 都是可重入锁
可重入锁最大的作用是避免死锁


## 介绍
线程安全和不安全的序列号生成器